---
title: 'Übung 04: Das Torkeln des Marsmondes Phobos'
author: "Tobias Blesgen und Leonardo Thome"
date: "23.06.2021"
output:
  pdf_document: default
  html_document:
    df_print: paged
header-includes: 
 - \usepackage{amssymb}
 - \usepackage{amsmath}
 - \usepackage[ngerman]{babel}
 - \bibliographystyle{unsrtnat}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Im Folgenden wollen wir das Torkeln des Marsmondes Phobos untersuchen, welches durch die Ellipsoideform des Modes und der elliptischen Umlaufbahn um den Mars entsteht.

Dazu beschreiben wir die Situation wie folgt:

Wir nehmen an, dass der Mond Phobos den Mars auf einer festen elliptischen Bahn mit Radius $r(t)$, Polarwinkel $\phi(t)$, großen Halbachse $a$ und Exzentrizität $\epsilon$ in der Umlaufzeit $T$ umkreist.
Die Eigenbewegung von Phobos wird durch den Winkel $\theta(t)$ beschrieben. Mit den drei Trägheitsmomenten $I_1 < I_2 < I_3$ von Phobos, kann die Bewegungsgleichung für die Eigenbewegung wie folgt geschrieben werden:

\begin{equation}
      I_3 \ddot\theta(t) = -\frac{3}{2} (\frac{2\pi}{T})^2 (I_2-I_1)(\frac{a}{r(t)})^3 \sin{2(\theta(t)-\phi(t))}
\end{equation}

Mit der Größe $\alpha= \sqrt{3\frac{I_2-I_1}{I_3}}$ vereinfachen  wir die Gleichung zu:

\begin{equation}
      \ddot\theta(t) = -\frac{\alpha^2}{2} (\frac{2\pi}{T})^2 (\frac{a}{r(t)})^3 \sin{2(\theta(t)-\phi(t))}
\end{equation}
Dabei lässt sich die Differentialgleichung 2.Ordnung auch als 2 Differentialgleichungen 1.Ordnung schreiben:
\begin{equation}
      \frac{\mathrm{d} \theta(t)}{\mathrm{d} t} = \dot \theta
\end{equation}
\begin{equation}
      \frac{\mathrm{d}  \dot\theta(t)}{\mathrm{d} t} = -\frac{\alpha^2}{2} (\frac{2\pi}{T})^2 (\frac{a}{r(t)})^3 \sin{2(\theta(t)-\phi(t))}
\end{equation}

Da $r(t)$ und $\phi(t)$ selbst zeitabhängig sind, müssen wir erst diese lösen, um  die Lösung zu $\theta(t)$ finden zu können.

Nach den Keplerschen Gesetzen erhalten wir die Beziehung (QUELLE):
\begin{equation}
      r(\phi) = \frac{p}{1+\epsilon \cos{\phi}} = \frac{a (1-\epsilon^2)}{1+\epsilon \cos{\phi}}
\end{equation}
und für die Ableitung nach dem Winkel:
\begin{equation} \label{eq:rPunkt}
      \frac{\partial r(\phi)}{\partial \phi} = \frac{a (1-\epsilon^2)\epsilon \sin{\phi}}{(1+\epsilon \cos{\phi})^2}
\end{equation}
Aus der Drehimpulserhaltung können wir folgern:
\begin{align}
      L &= M r^2 * \dot \phi = const  \\
      \leftrightarrow{\dot \phi} &= \frac{L}{M}\frac{1}{r^2}
\end{align}
Für die zeitliche Ableitung von $r$ ergibt sich mit Hilfe der Gleichungen (\ref{eq:rPunkt}) \& (?):

\begin{equation}
      \dot r = \frac{\partial r}{\partial \phi}\frac{\partial \phi}{\partial t} = \frac{a (1-\epsilon^2)\epsilon \sin{\phi}}{(1+\epsilon \cos{\phi})^2}\frac{L}{M}\frac{1}{r^2}
\end{equation}

Mit den 4 Differntialgleichung können wir nun $\theta(t)$ und $\dot \theta(t)$ bestimmen ($r$ ist dabei in Einheiten von a).

\begin{equation}
      \frac{\mathrm{d} \phi}{\mathrm{d} t} = \frac{L}{M}\frac{1}{r^2}
\end{equation}
\begin{equation}
      \frac{\mathrm{d} r}{\mathrm{d} t} = \frac{a (1-\epsilon^2)\epsilon \sin{\phi}}{(1+\epsilon \cos{\phi})^2}\frac{L}{M}\frac{1}{r^2}
\end{equation}
\begin{equation}
      \frac{\mathrm{d} \theta(t)}{\mathrm{d} t} = \dot \theta
\end{equation}
\begin{equation}
      \frac{\mathrm{d}  \dot\theta(t)}{\mathrm{d} t} = -\frac{\alpha^2}{2} (\frac{2\pi}{T})^2 (\frac{1}{r(t)})^3 \sin{2(\theta(t)-\phi(t))}
\end{equation}

Für die entgültige Implementierung wollen die Differientiallgleichung nach 

# Runge-Kutta 2 Verfahren

Um das Differentialgleichungssysteme auszuwerten, verwenden wir das Runge-Kutta Verfahren nach

\begin{equation}
  x_{i+1} = x_i + \frac{h}{2}[f(t_i, x_i) + f(t_i+h, x_i+h f(t_i,x_i))].
\end{equation}

Wobei sich unser f aus den vier Anteilen von $\phi$, $r$, $\theta$ und $\dot \theta$ zusammensetzt.

Dabei bietet uns das Runge-Kutter Verfahren numerische Stabilität (soweit das System selbst Stabile ist) und weist mit einem Verfahrensfehler von $\mathcal{O}(h^2)$ einen kleineren Fehler als das Eulerverfahren auf bei keinen Schrittweiten h.

# Implementation des DGS nach dem Runge-Kutta 2 Verfahren

```{Rcpp}
#include<Rcpp.h>
#include<stdlib.h>
#include<vector>
#include<algorithm>

using namespace Rcpp;

// Wir verwenden Strukturen, um Funktionsargumente uebersichtlicher zu halten
typedef struct
{
    double phi, r, theta, thetadot;
} Status;

typedef struct
{
    double epsilon,LM,ktheta;
} Parameter;

// Template zum Zerschneiden der verwendeten Vektoren
template<typename T>
std::vector<T> slice(std::vector<T> const &v, int m, int n)
{
    auto erste = v.cbegin() + m;
    auto letzte = v.cbegin() + n + 1;
 
    std::vector<T> vektor(erste, letzte);
    return vektor;
}

// Berechnungsschritt der Ableitungen nach dem DGS
void f(Status alterStatus, Parameter parameter, Status& neuerStatus){

  neuerStatus.r = parameter.LM*(1-parameter.epsilon*parameter.epsilon)
    *parameter.epsilon*sin(alterStatus.phi)/(alterStatus.r*alterStatus.r
    *(1+parameter.epsilon*cos(alterStatus.phi))*(1+parameter.epsilon
    *cos(alterStatus.phi)));
                                                                                                                                               
    neuerStatus.phi = parameter.LM/(alterStatus.r*alterStatus.r);
    
    neuerStatus.theta = alterStatus.thetadot;
    
    neuerStatus.thetadot = parameter.ktheta*sin(2*(alterStatus.theta
      -alterStatus.phi))/(alterStatus.r*alterStatus.r*alterStatus.r);
    
}

// Ein Intergrationsschritt nach Runge-Kutta
void rkSchritt(Status& status, Parameter parameter, double h){
    Status fStatus;                 // Standart Ableitung
    f(status, parameter, fStatus);
    
    Status f2Status;                // Mischterm Ableitung
    Status gemischt = {.phi=status.phi+h*fStatus.phi,.r = status.r+h*fStatus.r,
                       .theta = status.theta + h*fStatus.theta,
                       .thetadot = status.thetadot + h*fStatus.thetadot};
    
    f(gemischt, parameter, f2Status);
    status.phi = status.phi + h/2*(fStatus.phi + f2Status.phi);
    status.r = status.r+ h/2*(fStatus.r + f2Status.r);
    status.theta = status.theta + h/2*(fStatus.theta + f2Status.theta);
    status.thetadot = status.thetadot+h/2*(fStatus.thetadot+f2Status.thetadot);
    }

//[[Rcpp::export]]
Rcpp::List durchlauf(const int maxSchritte, const double h,
                            const double phi, const double r, const double theta,
                            const double thetadot,const double epsilon,
                            const double LM, const double ktheta){
  // Arrays der Werte zur späteren Ausgabe
    std::vector<double> phiWerte(maxSchritte);
    std::vector<double> rWerte(maxSchritte);
    std::vector<double> thetaWerte(maxSchritte);
    std::vector<double> thetadotWerte(maxSchritte);
    int k = 0;
  // Quelltext
  Status status = {.phi = phi, .r = r, .theta = theta,.thetadot = thetadot};
  Parameter parameter = {.epsilon = epsilon,.LM = LM, .ktheta = ktheta};
  // Schleife bis zur Abbruchsbedingung
    for (int i = 0; i < maxSchritte; i++){
      phiWerte[i] = status.phi;
      rWerte[i] = status.r;
      rkSchritt(status, parameter, h);
      
      // theta und thetadot Aufnahme nach jeder Umrundung
      if(status.phi >= 2*3.14159*k){
        k++;
        thetaWerte[k] = status.theta;
        thetadotWerte[k] = status.thetadot;
      }
    }
    
  // Rückgabe für eine grafische Wiedergabe
    return List::create(Named("phi") = phiWerte,Named("r") = rWerte,
                        Named("theta") = slice(thetaWerte,1,k-1),
                        Named("thetadot") = slice(thetadotWerte,1,k-1));
}

```

Für eine Exzentrizität von 0 ergibt sich ein konstanter Radius, siehe Abb. \ref{fig:grundEntwicklung}
```{r, echo=FALSE}
#Anfangsbedingungen und Konstanten

epsilon = 0;
alpha = 0.83;
x0 = 0;
phi = 0;
r = 1-epsilon^2;
# Mit der Umformung nach tau.
ktheta = -1/2*alpha^2;


#Wählen als Drehimpuls Masse Verhältnis 0,5
L = 0.5;
m = 1;
LM = L/m;


#Vaariation der Anfangsbedingungen
theta = 0;
thetadot = 1;


#Schrittwahl
h = 0.001
schritte = 1000000

e0 = durchlauf(schritte, h, phi, r, theta, thetadot, epsilon, LM, ktheta, x0)
```

Wir finden in Abb. \ref{fig:grundEntwicklung2} ein sinusförmiges, regelmäßiges Verhalten der Eigenrotation.

```{r, echo=FALSE, fig.cap="\\label{fig:grundEntwicklung2} Entwicklungskurven für $R_0 = 2.9$"}
library(latex2exp)
plot(e0$theta, e0$thetadot, "p", col = "dark blue",xlab=TeX(r'($\theta$)'), ylab = TeX(r'($T d_t \theta  / 2 \pi$)'))
```

Wir verwenden nun die Werte von Phobos, also $\epsilon = 0,015$ und $\alpha = 0,83$. Wir finden für XYZ in Abb. \ref{fig:grundEntwicklung3} ein chaotisches Verhalten.

```{r, echo=FALSE}
#Anfangsbedingungen und Konstanten
epsilon = 0.015;
alpha = 0.83;
x0 = 0;
phi = 0;
r = 1-epsilon^2;
ktheta = -1/2*alpha^2;


#Wählen als Drehimpuls Masse Verhältnis 0,5
L = 0.50;
m = 1;
LM = L/m;


#Vaariation der Anfangsbedingungen
theta = 0;
thetadot = 1;

#Schrittwahl
h = 0.001
schritte = 1000000

phobos = durchlauf(schritte, h, phi, r, theta, thetadot, epsilon, LM, ktheta, 
                   x0)
```


```{r, echo=FALSE, fig.cap="\\label{fig:grundEntwicklung3} Entwicklungskurven für $R_0 = 2.9$"}
library(latex2exp)
plot(phobos$theta, phobos$thetadot,"p", col = "dark blue",xlab=TeX(r'($\theta$)'), ylab = TeX(r'($T d_t \theta  / 2 \pi$)'))
```





# Fazit
Auch wenn wir bei spezifischen Werten Periodisches Verhalten zwischen $\theta$
und $\dot \theta$ erhalten, wie auch erwartet.
Jedoch sollte dies nicht wie bei uns gespiegelt. Es scheind das uns eine Fehler bei dem Aufstellen der DGL unterlaufen zu sein,
den wir nicht finden.
Wir können aber sehen, dass das bei der Wahl von verschiedenen Anfangsbedingungen chaotisches Verhalten auftritt (siehe Plots).




\begin{thebibliography}{99}

\end{thebibliography}